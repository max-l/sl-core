package net.strong_links.core

import java.util.Locale
import scala.collection.mutable.{SynchronizedMap, HashMap}
import java.util.IdentityHashMap

object I18nUtil {
  def makeLanguageKey(language: String, country: String): String = {
    country match {
      case "" => language.toLowerCase
      case _ => language.toLowerCase + "_" + country.toUpperCase
    }
  }
  
  def makeLanguageKey(locale: Locale): String = {
    makeLanguageKey(locale.getLanguage, locale.getCountry)
  }

  def classNameFor(packageName: String, languageKey: String) = {
    packageName.split('.').map(_.capitalize).mkString + "_" + languageKey   
  }
}

/**
 * This object caches the various Locales. Locales must exist only *once* in the system
 * because they are compared on their reference for speed. Thus, the only way to get
 * a locale is by calling the apply method of this object.
 */
object I18nLocale {
  private val cache = new HashMap[String, Locale] with SynchronizedMap[String, Locale]
  
  def notNull(s: String) = if (s == null) "" else s

  def apply(language: String, country: String = ""): Locale = {
    val languageKey = I18nUtil.makeLanguageKey(language, country)
    if (!cache.contains(languageKey))
      cache += (languageKey -> new Locale(language, country))
    cache(languageKey)
  }
  
  def apply(locale: Locale): Locale = {
    apply(notNull(locale.getLanguage), notNull(locale.getCountry))
  }
  
  def getLocaleFor(language: String, country: String = ""): Locale = {
    val languageKey = I18nUtil.makeLanguageKey(language, country)
    cache.get(languageKey) match {
      case None => Errors.fatal("No locale found for language key _." << languageKey)
      case Some(locale) => locale
    }
  }

  def getLocaleFor(locale: Locale): Locale = {
    getLocaleFor(notNull(locale.getLanguage), notNull(locale.getCountry))
  }

  def checkLocale(locale: Locale) = {
    if (getLocaleFor(locale.getLanguage, locale.getCountry) != locale)
      Errors.fatal("Locale has not been generated by I18nLocales.")
  }
}

class I18nGettextClass(packageName: String, locale: Locale, parentClass: Option[I18nGettextClass]) {
  private val languageKey = I18nUtil.makeLanguageKey(locale)
  private val dynamicClassName = I18nUtil.classNameFor(packageName, languageKey)
  private val dynamicClass = loadIt
   
  private def loadIt = {
    val targetClass = try Class.forName(dynamicClassName) catch {
      case e: Exception => Errors.fatal("Can't load class _ (_)." << (dynamicClassName, e.getMessage))
    }
    val classInstance = try targetClass.newInstance catch {
      case e: Exception => Errors.fatal("Can't instantiate class _ (_)." << (dynamicClassName, e.getMessage))
    }
    val dc = classInstance.asInstanceOf[{
      val languageKey: String
      val nbEntries: Int
      val nbPluralForms: Int
      val pluralForms: String
      val generatedAt: String
      val javaVersion: String
      def computePluralForm(n: Int): Int
      def gettext(msgid: String): String
      def ngettext(msgid: String, n: Int): String
    }]
    if (dc.languageKey != languageKey)
      Errors.fatal("Invalid language key _ for class _ ; _ was expected." 
                  << (dc.languageKey, dynamicClassName, languageKey))
    dc
  }
  
  def gettext(key: String): String = {
    val translation = dynamicClass.gettext(key)
    if (translation == "")
      parentClass match {
        case None => ""
        case Some(pc) => pc.gettext(key)
      } 
    else
      translation
  }

  def ngettext(key: String, n: Int): String = {
    val translation = dynamicClass.ngettext(key, n)
    if (translation == "")
      parentClass match {
        case None => ""
        case Some(pc) => pc.ngettext(key, n)
      }  
    else
      translation
  }
}

/**
 * This class holds all the translation classes for a given package. The 'useSingular' function
 * determines whether the singular form must be used for a given 'n', for the default locale used to
 * write the source code. This parameter is optional, and it defaults to the rules for the English language.
 * 
 * TODO: update doc
 * 
 */
class I18nCatalog(val packageName: String, val codeLocale: Locale, 
                  val usePlural: (Int) => Boolean) {
  
  private val loadedClasses = new IdentityHashMap[Locale, I18nGettextClass]()
  
  def loadTranslationClass(locale: Locale, parentClass: Option[I18nGettextClass] = None)  = {
    // Make sure we know this locale
    I18nLocale.checkLocale(locale)
    if (loadedClasses.containsKey(locale))
      Errors.fatal("Translation class already loaded for package _ and language key _." << (packageName, I18nUtil.makeLanguageKey(locale)))
    val gettextClass = new I18nGettextClass(packageName, locale, parentClass)
    loadedClasses.put(locale, gettextClass)
    gettextClass
  }
  
  def translationClassFor(locale: Locale) = {
    val result = loadedClasses.get(locale)
    if (result == null)
      Errors.fatal("Translation class not loaded for package _ and language key _." << (packageName, I18nUtil.makeLanguageKey(locale)))
    result
  }
}

protected class I18n(val catalog: I18nCatalog, val msgCtxt: Option[String], val msgid: String, 
                     val msgidPlural: Option[String], val n: Int) {
  
  def toString(locale: Locale): String = {
    
    def default = msgidPlural match { case None => msgid; case Some(p) => if (catalog.usePlural(n)) p else msgid }
    
    if (locale eq catalog.codeLocale)
      default
    else {
      val tc = catalog.translationClassFor(locale)
      val searchedMsgid = msgCtxt match {
        case None => msgid
        case Some(ctx) => (ctx + "\u0000" + msgid).intern
      }
      val translation = msgidPlural match {
        case None => tc.gettext(searchedMsgid)
        case _ => tc.ngettext(searchedMsgid, n)
      }
      if (translation == "")
        default
      else
        translation
    }
  }
    
  override def toString: String = {
    var locale = userLocale.unsafeGet
    if (locale == null)
      locale = I18n.systemLocale
    toString(locale) 
  }
  
  def << (args: Any*) = {
    new PluggedI18n(this, Some(args), false)
  }

  def <<< (args: Any*) = {
    new PluggedI18n(this, Some(args), true)
  }
}

class PluggedI18n(from: I18n, args: Option[Seq[Any]], quotedDefault: Boolean) 
  extends I18n(from.catalog, from.msgCtxt, from.msgid, from.msgidPlural, from.n) {
  
  override def toString: String = {
    toString(false, quotedDefault)
  }
  
  def toString(failsafe: Boolean, quoted: Boolean): String = {
    PluggedArguments.format(super.toString, args, failsafe, quoted)
 }
}

object I18n {
  
  // System locale at startup. This is *not* expected to change in a server environment.
  val systemLocale = I18nLocale(Locale.getDefault)
  
  def apply(msgid: String)(implicit catalog: I18nCatalog) =
    new I18n(catalog, None, msgid, None, 0)
}    

object I18nPlural {
  def apply(msgid: String, msgidPlural: String, n: Int)(implicit catalog: I18nCatalog) =
    new I18n(catalog, None, msgid, Some(msgidPlural), n)
}

object I18nCtxt {
  def apply(msgCtxt: String, msgid: String)(implicit catalog: I18nCatalog) =
    new I18n(catalog, Some(msgCtxt), msgid, None, 0)
}    

object I18nPluralCtxt {
  def apply(msgCtxt: String, msgid: String, msgPlural: String, n: Int)(implicit catalog: I18nCatalog) =
    new I18n(catalog, Some(msgCtxt), msgid, Some(msgPlural), n)
}

abstract class GeneralString

class StringGeneralString(s: String) extends GeneralString {
  override def toString = s
}

class I18nGeneralString(i18n: I18n) extends GeneralString {
  override def toString = i18n.toString
}
